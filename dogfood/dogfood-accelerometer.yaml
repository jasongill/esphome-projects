esphome:
  name: dogfood
  name_add_mac_suffix: true
  platformio_options:
    upload_speed: 460800
    build_flags:
        - -DgetDCHighVoltagePowerDowmEn=getDCHighVoltagePowerDownEn
        - -DgetDC1LowVoltagePowerDowmEn=getDC1LowVoltagePowerDownEn
        - -DgetDC2LowVoltagePowerDowmEn=getDC2LowVoltagePowerDownEn
        - -DgetDC3LowVoltagePowerDowmEn=getDC3LowVoltagePowerDownEn
        - -DgetDC4LowVoltagePowerDowmEn=getDC4LowVoltagePowerDownEn
        - -DgetDC5LowVoltagePowerDowmEn=getDC5LowVoltagePowerDownEn
  libraries:
    - lewisxhe/XPowersLib @ ^0.2.6
  on_boot:
    priority: 900
    then:
      - component.update: axp
      - delay: 200ms

esp32:
  board: m5stack-core2
  framework:
    type: arduino
    version: recommended

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

debug:

captive_portal:

web_server:
  port: 80

logger:
    level: INFO

api:

ota:
  - platform: esphome

time:
  - platform: sntp
    id: sntp_time
    timezone: America/New_York

number:
  - platform: template
    id: dogs_get_hungry_after_hours
    name: "Dogs Get Hungry After"
    icon: mdi:timer-sand
    unit_of_measurement: hours
    min_value: 0
    max_value: 24
    step: 1
    initial_value: '8'
    restore_value: yes
    optimistic: true
  - platform: template
    id: tilt_threshold
    name: "Tilt Threshold"
    unit_of_measurement: degrees
    icon: mdi:axis-arrow
    min_value: 0
    max_value: 90
    step: 1
    initial_value: "20"
    restore_value: yes
    optimistic: true

globals:
  - id: last_fed_epoch
    type: time_t
    restore_value: yes
    initial_value: '0'

script:
  - id: mark_fed
    then:
      - lambda: |-
          auto now = id(sntp_time).now();
          if (!now.is_valid()) {
            ESP_LOGW("dogfood","Time not yet set, ignoring feeding");
            return;
          }
          if (id(last_fed_epoch) && (now.timestamp - id(last_fed_epoch)) < 60) {
            ESP_LOGI("dogfood","Feeding already recorded in last 60 seconds, ignoring feeding");
            return;
          }
          ESP_LOGI("dogfood","Feeding recorded");
          id(last_fed_epoch) = now.timestamp;
      - component.update: last_fed_epoch_sensor

spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23

i2c:
  - id: bus_a
    sda: GPIO21
    scl: GPIO22
    scan: true
    frequency: 400kHz

sensor:
  - platform: template
    id: last_fed_epoch_sensor
    name: "Dogs Last Fed"
    device_class: timestamp
    icon: mdi:dog
    update_interval: 60s
    lambda: |-
      if (id(last_fed_epoch) == 0) return NAN;
      return (float) id(last_fed_epoch);
  - platform: mpu6886
    address: 104
    update_interval: 200ms
    accel_x:
      internal: true
      id: accel_x
    accel_y:
      internal: true
      id: accel_y
    accel_z:
      internal: true
      id: accel_z
  - platform: axp2101
    model: M5CORE2
    address: 0x34
    i2c_id: bus_a
    id: axp
    update_interval: 30s
    battery_level:
      name: "Battery Level"
      id: battery_level
    battery_voltage:
      name: "Battery Voltage"
      id: battery_voltage

font:
  - file: 'gfonts://Roboto'
    id: font_lg
    size: 48
  - file: 'gfonts://Roboto'
    id: font_md
    size: 36
  - file: 'gfonts://Roboto'
    id: font_sm
    size: 20
  - file: 'gfonts://Noto+Emoji'
    id: emoji_sm
    size: 28
    glyphs: "ðŸ”‹"

display:
  - platform: ili9xxx
    model: ili9342
    cs_pin: GPIO5
    dc_pin: GPIO15
    invert_colors: true
    show_test_card: false
    dimensions:
      width: 320
      height: 240
    transform:
      mirror_x: false
    update_interval: 1s
    lambda: |-
      auto textcolor = Color::WHITE; 
      it.fill(Color::BLACK);
      auto now = id(sntp_time).now();
      if (id(last_fed_epoch) != 0 && now.is_valid()) {
        const uint32_t diff = now.timestamp - id(last_fed_epoch);
        const int h = (diff % 86400) / 3600, m = (diff % 3600) / 60, s = diff % 60;
        if (id(dogs_are_hungry).state) {
          textcolor = Color::BLACK;
          it.fill(Color(255, 0, 0));
        }
        it.printf(160,20, id(font_md), textcolor, TextAlign::TOP_CENTER, "Dogs Last Fed");
        it.printf(160,80, id(font_lg), textcolor, TextAlign::TOP_CENTER, "%dh %dm %ds", h, m, s);
        auto fed_time = ESPTime::from_epoch_local(id(last_fed_epoch));
        char fed_buf[32];
        fed_time.strftime(fed_buf, sizeof(fed_buf), "%I:%M %p");
        if (fed_buf[0] == '0') {
          memmove(fed_buf, fed_buf + 1, strlen(fed_buf));
        }
        it.printf(160,140, id(font_md), textcolor, TextAlign::TOP_CENTER, "%s", fed_buf);
      }
      if (id(battery_level).has_state() && (int)id(battery_level).state < 100) {
        it.printf(160, 210, id(font_sm), textcolor, TextAlign::TOP_CENTER, "%d%%", (int)id(battery_level).state);
        it.printf(190, 208, id(emoji_sm), textcolor, TextAlign::TOP_CENTER, "ðŸ”‹");
      }

external_components:
  - source: github://stefanthoss/esphome-axp2101
    components: [axp2101]

binary_sensor:
  - platform: template
    id: lid_lifted
    device_class: opening
    lambda: |-
      if (!(id(accel_x).has_state() && id(accel_y).has_state() && id(accel_z).has_state()))
        return false;
    
      const float ax = id(accel_x).state;
      const float ay = id(accel_y).state;
      const float az = id(accel_z).state;
      const float g  = sqrtf(ax*ax + ay*ay + az*az);
      if (g < 1.0f) return false;
    
      const float thresh_deg = id(tilt_threshold).state;
      const float cos_t = cosf(thresh_deg * 0.0174532925f);
      const float g_cos_t = g * cos_t;
    
      return fabsf(ax) < g_cos_t ||
             fabsf(ay) < g_cos_t ||
             fabsf(az) < g_cos_t;
    filters:
      - delayed_on: 500ms
      - delayed_off: 2s
    on_press:
      - script.execute: mark_fed
  - platform: template
    id: dogs_are_hungry
    name: "Dogs Are Hungry"
    lambda: |-
      auto now = id(sntp_time).now();
      if (id(last_fed_epoch) != 0 && now.is_valid()) {
        const uint32_t diff = now.timestamp - id(last_fed_epoch);
        const int h = (diff % 86400) / 3600;
        return h >= id(dogs_get_hungry_after_hours).state;
      }
      return false;
